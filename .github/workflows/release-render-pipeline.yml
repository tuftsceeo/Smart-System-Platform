name: release-render-pipeline

on:
  pull_request:
    types:
      - closed
    branches:
      - main

jobs:
  release-render:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        ssh-key: ${{ secrets.RENDER_KEY }}

    - name: Set up SSH for Git
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.RENDER_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan github.com >> ~/.ssh/known_hosts
        eval "$(ssh-agent -s)"
        ssh-add ~/.ssh/id_rsa

    - name: Parse File List from release/all/README.qmd
      id: parse
      run: |
        # Extract the table section and parse the file paths
        raw_file_list=$(awk '/\| name/ {f=1; next} /\|----/ {next} f && /\|/ {print $2}' software/release/all/README.qmd | tr -d ' ')
    
        file_list=$(echo "$raw_file_list" | sed 's/^/software\//')
    
        echo "Files to monitor:"
        echo "$file_list"
    
        echo "file_list<<EOF" >> $GITHUB_OUTPUT
        echo "$file_list" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Copy Files to Release All Folder
      run: |
        mkdir -p software/release/all  # Ensure the release all folder exists
        echo "${{ steps.parse.outputs.file_list }}" | while read file; do
          # Skip the config.py file
          if [[ "$(basename $file)" == "config.py" ]]; then
            echo "Skipping config.py"
            continue
          fi
          
          # Copy the file, overwriting if it already exists
          cp "$file" software/release/all/  # Overwrite files directly to the root of the release all folder
        done

    - name: List Files in Release All Folder
      run: |
        echo "Files copied to the release all folder:"
        find software/release/all -type f


    - name: Update Version in Config.py
      run: |
        changed_files=$(git diff --name-only)
        new_files=$(git ls-files --others --exclude-standard)
        all_changed_files=$(echo "$changed_files $new_files" | tr ' ' '\n')

        echo "${{ steps.parse.outputs.file_list }}" | while read file; do
          base_file=$(basename "$file")

          if echo "$all_changed_files" | grep -q "$base_file"; then
            if grep -q "$base_file" software/release/all/config.py; then
              current_version=$(sed -n "s/^.*'$base_file': \([0-9]*\),.*$/\1/p" software/release/all/config.py)
              current_version=${current_version:-0}   # Default to 0 if empty
              new_version=$((current_version + 1))

              sed -i "s/^.*'$base_file': $current_version,.*$/'$base_file': $new_version,/g" software/release/all/config.py
              echo "Updated $base_file version from $current_version to $new_version"
            else
              sed -i "/^version = {/a \ \ \ \ '$base_file': 1," software/release/all/config.py
              echo "Added $base_file with version 1"
            fi
          else
            echo "No change detected for $base_file"
          fi
        done
        
    - name: Copy files from "all" and update config.py
      run: |
        release_root="software/release"
        all_folder="$release_root/all"
    
        for folder in "$release_root"/*/; do
          folder_name=$(basename "$folder")
          if [ "$folder_name" = "all" ]; then
            continue
          fi
    
          qmd_file="$folder/README.qmd"
          if [ ! -f "$qmd_file" ]; then
            echo "Skipping $folder_name — no README.qmd found."
            continue
          fi
    
          echo "Processing $folder_name..."
    
          # --- Copy files listed in README.qmd from 'all/' ---
          files=$(awk '/\| name/ {f=1; next} /\|----/ {next} f && /\|/ {print $2}' "$qmd_file" | tr -d ' ')
          for file in $files; do
            src="$all_folder/$file"
            dest="$folder"
            if [ -f "$src" ]; then
              echo "Copying $file → $folder_name/"
              cp "$src" "$dest/"
            else
              echo "Warning: $file not found in all/"
            fi
          done
    
          # --- Update config.py ---
          config_file="$folder/config.py"
          if [ ! -f "$config_file" ]; then
            echo "Warning: $config_file not found, skipping config update"
            continue
          fi
    
          python3 - <<EOF
          import os, re, datetime
          
          file_path = "$config_file"
          folder_name = "$folder_name"
          
          with open(file_path) as f:
              content = f.read()
          
          # List of Python files in the folder
          py_files = [f for f in os.listdir(os.path.dirname(file_path)) if f.endswith('.py') and f != "config.py"]
          
          # Update config dict with timestamp including minutes & seconds
          version_str = datetime.datetime.now().strftime("%Y.%m.%d-%H%M%S")
          new_config = (
              "{'ap_channel': 1, 'id': None, 'name': 'Nick', "
              f"'sta_mac': None, 'ap_mac': None, 'configuration': '{folder_name}', "
              "'sta_channel': 1, 'version': '" + version_str + "'}"
          )
          content = re.sub(r"config\s*=\s*\{.*?\}", f"config = {new_config}", content, flags=re.DOTALL)
          
          # Clean and rebuild version dict
          match = re.search(r"version\s*=\s*\{(.*?)\}", content, flags=re.DOTALL)
          version_dict = {}
          if match:
              existing_versions = match.group(1)
              for line in existing_versions.splitlines():
                  m = re.search(r"'([^']+)':\s*(\d+)", line)
                  if m:
                      version_dict[m.group(1)] = int(m.group(2))
          
          # Keep only existing files, add missing ones with version 1
          version_dict = {f: v for f, v in version_dict.items() if f in py_files}
          for f in py_files:
              if f not in version_dict:
                  version_dict[f] = 1
          
          # Rebuild version block
          version_lines = ",\n    ".join([f"'{k}': {v}" for k, v in sorted(version_dict.items())])
          new_version_block = f"version = {{\n    {version_lines}\n}}"
          
          content = re.sub(r"version\s*=\s*\{.*?\}", new_version_block, content, flags=re.DOTALL)
          
          with open(file_path, "w") as f:
              f.write(content)
EOF

        done
            
    - name: Set up R
      uses: r-lib/actions/setup-r@v2

    - name: Install Required R Packages
      run: |
        Rscript -e 'if (!requireNamespace("rmarkdown", quietly = TRUE)) install.packages("rmarkdown", repos = "https://cloud.r-project.org/")'
        Rscript -e 'if (!requireNamespace("knitr", quietly = TRUE)) install.packages("knitr", repos = "https://cloud.r-project.org/")'

    - name: Set up Quarto
      uses: quarto-dev/quarto-actions/setup@v2

    - name: Find and Render README.qmd Files
      run: |
        find . -name "README.qmd" | while read qmd_file; do
          quarto render "$qmd_file" --to gfm
        done

    # --- Step 4: Commit and Push All Changes Once ---
    - name: Commit and Push All Changes
      run: |
        # Configure Git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        # Check if there are changes to commit (release folder or rendered README files)
        git diff --exit-code || (git add software/release/ && git add . && git commit -m "Release and Render")

        # Push the changes if there were any
        git push origin main || echo "No changes to push"

    - name: Set up Pull Request from main to original branch
      env:
          GH_TOKEN: ${{ github.token }}
      run: |
        # Ensure the latest changes from remote are fetched
        git fetch origin
        
        # Get the original branch from the pull request
        original_branch="dev/nick"
        
        # Check if the original branch exists
        if git show-ref --verify --quiet "refs/remotes/origin/$original_branch"; then
          # Create a pull request from main to the original branch
          pr_url=$(gh pr create --base "$original_branch" --head "main" --title "Sync main with $original_branch" --body "Automated sync from main branch" --fill || echo "")
          
          # Merge the pull request if created
          if [[ -n "$pr_url" ]]; then
            pr_number=$(echo "$pr_url" | grep -oP '\d+$')
            gh pr merge "$pr_number" --merge --admin || echo "Failed to merge PR $pr_number"
          else
            echo "No new pull request was created."
          fi
        else
          echo "Error: The branch '$original_branch' does not exist remotely."
        fi
