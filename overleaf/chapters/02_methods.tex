\cleardoublepage%
\chapter{\label{chap:methods}Methodology}%

The research in this thesis can be divided into three distinct phases, Section \ref{sec:methods_ph1} Phase 1 consists of the analysis of the Smart Motor system, the literature and technology review, and the design of the networking and platform architecture, including a framework and guiding principles. Section \ref{sec:methods_ph2} Phase 2 describes the development of the networking and the supporting Smart System Platform, including some of its key features such as the GitHub page, the website, and various development and management tools. Section \ref{sec:methods_ph3} Phase 3 outlines the methodology for testing, validating and deploying the designed platform and networking capabilities.

\section{\label{sec:methods_ph1}Phase 1: Analysis and Design}

The first step, detailed in Section \ref{sec:methods_sm_analysis}, was to dissect and analyse the existing Smart Motor project, its system design and the technology used. In Section \ref{sec:methods_tech_review} all components of the Smart Motor v3 are examined. 
In this section, other systems and technologies are also examined, particularly with regard to networking solutions, focusing on, but not limited to, the components examined as part of the Smart Motors. 
Based on this analysis, a network design concept was developed, which is described in Section \ref{sec:methods_net_des}. Furthermore, based on considerations of how to support and provide accessibility to the system and its networking capabilities, a concept for an overarching system architecture, including supporting tools, development whatnot, was designed and is presented in Section \ref{sec:methods_ssp_des}.
%Iterative development of both the platform and the other stuff, make it future ready

\subsection{\label{sec:methods_sm_analysis}Smart Motor Technology Analysis and Review}

As defined by \citet[]{dahal_designing_2024}, the main components of the Smart Motor concept and how they interact are shown in Figure \ref{fig:sm_schematic} and consist of the MC as the brain of the system in its centre, a sensor input, a motor output and a user interface (UI) that provides both input and output and enables user-system interaction.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{overleaf/images/sm_concept.png}
    \vspace{\ftspace}
    \caption{General schematic of a Smart Motor system, adapted from \citet[p. 19]{dahal_designing_2024}}
    \label{fig:sm_schematic}
\end{figure}

There are two different modes of operation, \textit{Training} and \textit{Playing}. In the training mode, the user matches a given sensor input $S_n$ to a manually set motor output (either position or speed) $P_n$ using the UI, where $n$ is the index of the input data pair.
In play mode, the motor determines the output of the motor $P_{output}$ based on the current sensor input $S_{current}$ using a simplified nearest-neighbour algorithm described in Equation \ref{ml_nn_eq} with the machine learning (ML) training data provided by the user during the training mode, if $n \geq 1$.

\begin{equation}\label{ml_nn_eq}
    P_{\text{output}} = P_{arg\ min_{x \in {1,\ldots,n}} |S_{\text{current}} - S_x|}
\end{equation}

The simple algorithm compares the current sensor input $S_{current}$ with all $n$ stored sensor inputs $S_n$ from training and solves for which $S_x$ the Euclidean distance $|S_{current}-S_x|$ is minimal. As motor output $P_n$ and sensor input $S_n$ are always entered in pairs and therefore linked, the motor output $P_x$ is linked to the sensor input $S_x$ and is then used to set the output of the motor accordingly.
\\\\
This section focuses on the design, technology and function of the Smart Motor, with particular emphasis on the latest iteration of the Smart Motor, the Smart Motor v3 \citep[p. 38]{dahal_designing_2024}.

\subsubsection{\label{sec:methods_sm_mech}Hardware Design}

Physically, the Smart Motor v3 is cube-shaped, with its various components contained within the shell, with only the various physical interfaces visible on the surface. 
An OLED screen, a button and a potentiometer are located on the front face. There are two more buttons on the left, a Grove-compatible sensor port on the right, and a USB-C port on the bottom. The motor, either a servo or a continuous motor, extrudes on the top. The shell is a mix of 3D printed and laser-cut parts, with the newer version being fully 3D printed. Contained within the shell is a lithium polymer battery.

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/placeholder.png}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/placeholder.png}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/placeholder.png}
    \end{subfigure}
    \\\vspace{2pt}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/placeholder.png}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/placeholder.png}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/placeholder.png}
    \end{subfigure}
    \\\vspace{\ftspace}
    \caption{Smart Motor v3 displayed from each side. In the first row, from left to right views from the top, front and left are shown, while on the second row, from left to right, views from the right, back and bottom are displayed.}
    \vspace{\ftspace}
    \label{fig:smv3_hardware}
\end{figure}

There are two mechanical interfaces for the Smart Motor v3. One is the motor output, which protrudes from the top of the Smart Motor and is designed to mimic the connection of a LEGO Education motor, allowing LEGO pegs to be connected to the motor output of the Smart Motor. The other is the back of the Smart Motor shell, which is designed to accept LEGO connector pins, allowing components of the LEGO system in play to be attached to the motor or, conversely, the motor to be attached to a LEGO component-based structure. While the system is not directly compatible with LEGO bricks, the dimensions of the shell are approximately the size of a 6x6x5 brick. Specifically, the cube-shaped shell of the Smart Motor v3 is $47\ mm$ x $47\ mm$ x $47\ mm$ (W x B x H), which is the same size as a LEGO brick, making it partially compatible with the LEGO system in terms of pure dimensions. However, in newer iterations, the extrusions added to the side buttons extend beyond this frame, as do the button and potentiometer on the front and the motor on the top of the cube-shaped Smart Motor.

\subsubsection{\label{sec:methods_sm_elec}Electronics Component and Schematics}
The electronical schematics of the Smart Motor v3 closely resembles the general Smart Motor system outlined in Figure \ref{fig:sm_schematic}. The complete electronical system schematics, including all potential components, including wiring, are display in Figure \ref{fig:sm_elec_schematic}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{overleaf/images/placeholder.png}
    \vspace{\ftspace}
    \caption{Detailed electronic component schematic, including wiring, of the Smart Motor v3 and its custom PCB}
    \label{fig:sm_elec_schematic}
\end{figure}

At the heart of the system is a custom printed circuit board (PCB) called the Dahal Board, which houses a Seeed Studio XIAO ESP32C3 development board, powered by a ESP32C3-series System on Chip (SoC) microcontroller (MC). For simplicity sake, the Seeed Studio XIAO ESP32C3 will be referred to as the microcontroller-board (MCB). The MCB includes a USB-C connector, and the board provides various connection options, such as a Grove-compatible sensor port, two connections for a motor or other analogue outputs, as well as two I2C ports and a battery connection. A variety of components can be connected to the board, although in the case of the Smart Motor, the only fixed connections are to the motor, the screen, which is connected to one of the I2C ports and the battery. The board contains a built-in accelerometer which is used as the default sensor, although it is possible to connect and use other types of sensor to the external sensor port. The board also contains other types of user interface such as an OLED screen, two small buttons, one large button and a potentiometer to allow and enable user interaction directly on the system. A comprehensive list of the Smart Motor v3 components and their price are listed in Table \ref{tab:components}.

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/pcb_sch.png}
    \end{subfigure}
    \hspace{10pt}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/placeholder.png}
    \end{subfigure}
    \hspace{10pt}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/placeholder.png}
    \end{subfigure}
    \\\vspace{\ftspace}
    \caption{Schematic (left) and image  from top (middle) and bottom (right) of the Smart Motor v3 custom PCB (Dahal Board)}
    \label{fig:sm_dahal_board}
\end{figure}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|p{218pt}|l|}
        \hline
        \textbf{Name} & \textbf{Description} & \textbf{Price (USD)} \\
        \hline
        Dahal Board & Custom PCB, incl. MC, three buttons, a potentiometer, screen, on-board accelerometer and multiple connectors & 16.42 \$\quad\quad \\
        \hline
        \quad Seeed Studio XIAO ESP32C3 & \quad ESP32C3-based MCB (incl. in Dahal Board) & \quad\quad $4.99\ \$$ \\
        \hline
        \quad ? & \quad Screen (incl. in Dahal Board) & \quad\quad $?\  \$$ \\
        \hline
        \quad ? & \quad Button (incl. in Dahal Board) & \quad\quad $?\  \$$ \\
        \hline
        \quad ? & \quad Button (incl. in Dahal Board) & \quad\quad $?\  \$$ \\
        \hline
        \quad ? & \quad Potentiometer (incl. in Dahal Board) & \quad\quad $?\  \$$ \\
        \hline
        \quad ? & \quad Accelerometer (incl. in Dahal Board) & \quad\quad $?\  \$$ \\
        \hline
        Miuzei MG90S 9G & Servo motor & $2.76\  \$$ \\
        \hline
        Adafruit 4236 & Battery & $6.95\  \$$ \\
        \hline
         &  &  \\
        \hline
    \end{tabular}
    \\\vspace{\ftspace}
    \caption{Comprehensive list of all Smart Motor v3 electronic components}
    \label{tab:components}
\end{table}

\subsubsection{\label{sec:methods_sm_soft}Software Architecture}
The Smart Motor v3 runs on a slightly adapted version of the MicroPython firmware for ESP32-based MCs, such as the ESP32C3, which allows Python-based code to be run on the chipset. The use of MicroPython brings the advantage of extensive libraries and an active support community, making it easy to use and learn, which in turn makes the system and its code accessible to anyone with basic programming skills and access to a computer and a USB cable.
\\\\
The software that enables the Smart Motor logic to run consists of the main code and libraries to enable and support specific hardware components. All code files and their purpose are listed in Table \ref{tab:smv3_code_list}.

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Name} & \textbf{Purpose} \\
        \hline
        boot.py & empty \\
        \hline
        main.py & Main program,  \\
        \hline
         &  \\
        \hline
         &  \\
        \hline
         &  \\
        \hline
         &  \\
        \hline
         &  \\
        \hline
    \end{tabular}
    \vspace{\ftspace}
    \caption{List of all code files contained on the Smart Motor v3 and their purpose.}
    \label{tab:smv3_code_list}
\end{table}

The main program contains all the logic necessary for the Smart Motor to function as intended. It sets up and configures all the pins of the ESP32C3 chipset and initialises all the connected components, including the sensors, the motor and the user interface, which includes the screen, the main and two side buttons and the potentiometer. In the case of sensors, it detects whether an external sensor is present and, if not, defaults to using the on-board accelerometer. It also defines the different modes required, training and playing, and sets up the UI logic. It further sets up the button-press handlers and their logic and links the potentiometer to the motor output in the case of training mode. It also defines the ML principle and hosts the nearest neighbour algorithm that determines the motor output based on the current sensor input and training data for the game mode.
The further code files host various libraries and supporting code for the different components.

\subsubsection{\label{sec:methods_sm_ui}User Interface and Interaction Design}

One of the key design features of the Smart Motor concept is for the Smart Motor to used as a stand-alone unit, hence be trainable directly on the device, without the need of any supporting materiel. To this extent \citet[]{dahal_designing_2024} has come up with an interaction design and UI, enabling interaction of a user with the Smart Motor system. In the case of the Smart Motor v3, the UI includes a screen to display information in a graphic way, the two side buttons, used for navigation, the main button, used as a select button and a potentiometer, which in the training mode is linked to the motor, and used to set the motor position or speed.

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.19\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/train.png}
        \caption{Training screen:\\Add data-point\\\quad}
    \end{subfigure}
    \begin{subfigure}[b]{0.19\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/add.png}
        \caption{Training screen:\\Add data-point,\\One added point}
    \end{subfigure}
    \begin{subfigure}[b]{0.19\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/remove.png}
        \caption{Training screen:\\Remove data-point\\\quad}
    \end{subfigure}
    \begin{subfigure}[b]{0.19\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/trainplay.png}
        \caption{Training screen:\\Start playing mode\\\quad}
    \end{subfigure}
    \begin{subfigure}[b]{0.19\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/play.png}
        \caption{Playing screen:\\Two data-points\\\quad}
    \end{subfigure}
    \vspace{\ftspace}
    \caption{Screen UI for training- (a-d) and playing-mode (e) \citep[from][p. 40-41]{dahal_designing_2024}}
    \label{fig:screen}
\end{figure}

The design of the visual information on the screen, as shown in Figure \ref{fig:screen}, includes a battery indicator in the top left, an action indicator in the middle to bottom left, and spanning the rest of the screen is a two-dimensional plot showing the current motor position on the X-axis and the current sensor reading on the Y-axis in the form of lines. There is a small crosshair where these two lines meet. In training mode, which the SM v3 enters per default when starting up, there are three possible actions, with the current action being displayed by the action indicator. Switching between the actions is possible using the side button, while confirming the action can be done using the select button. 
\begin{enumerate}
    \item Adding Data-point:\\
    Training data, in the form of data points (linking a particular sensor reading to a particular motor position) can be added using the Select button, which adds a point at the location of the crosshairs using the current value of the motor and sensor, as shown in Figure \ref{fig:screen} (a). An added data point is displayed as a point on the graph at the position where the motor position value on the X-axis meets the sensor value on the Y-axis, as seen in Figure \ref{fig:screen} (b). These points represent the training data for the Smart Motor, which is used in its play mode to determine the motor output based on a sensor input using the nearest neighbour algorithm.
    \item Removing Data-point:\\
    Added data points can be removed using the remove action, shown in Figure \ref{fig:screen} (c), with data-points being removed in the reverse order of them being added.
    \item Enter Playing Mode:\\
    With the third action playing mode can be entered, as displayed in Figure \ref{fig:screen} (d). The playing mode is displayed as shown in Figure \ref{fig:screen} e. To exit the playing mode, the select button can be used to return to the screen in Figure \ref{fig:screen} (d) or one can directly use the side buttons to select a different action, which exits the playing mode in favour of training mode.
\end{enumerate}

\subsection{\label{sec:methods_tech_review}Technology and Literature Review}

 Most of the hardware, with the exception of the PCB and the Smart Motor v3 shell, are off-the-shelf components. As such, they inherently have more capability and application potential due to their general purpose design, which is particularly true for the ESP32C3-based MCB, which is examined in detail. ESP32C3 SoC-enabled networking options are also explored, such as Bluetooth and Wi-Fi, including previous work and solutions developed in this field, and finally the Seeed Studio Grove sensors are given brief consideration.

\subsubsection{\label{sec:rev_esp}ESP32 System-on-Chip Family}

ESP32 refers to a family of SoCs designed and developed by Espressif Systems, starting with the ESP32 series of SoCs manufactured by Taiwan Semiconductor Manufacturing Company Limited (TSMC) using their 40nm process \citep{espressif_systems_esp32_2025}.
Further series have been developed and released over time, including the ESP32C3 and ESP32C6 series, which Seeed Studio has used to develop the corresponding XIAO development boards. The first of these, the ESP32C3-based MCB, is of particular interest due to its use in the SM v3, though consideration will also be given to the newer ESP32C6-based MCB. Although even newer series of the SoC, such as the ESP32C5 and ESP32C61, have been announced and their respective chips are already available for purchase \citep{espressif_systems_esp_nodate}, their respective datasheets have not yet been released, nor is there any indication of development of the respective development boards by Seeed Studio at the time of writing.

\begin{figure}[H]
    \centering
    \begin{subfigure}{0.15\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/placeholder.png}
    \end{subfigure}
    \hspace{10pt}
    \begin{subfigure}{0.15\textwidth}
        \includegraphics[width=\linewidth]{overleaf/images/placeholder.png}
    \end{subfigure}
    \\\vspace{\ftspace}
    \caption{ESP32C3 SoC (left) and ESP32C6 SoC (right)}
    \label{fig:ESP32soc}
\end{figure}

\textbf{Seeed Studio XIAO ESP32C3}\\\\
The Seeed Studio XIAO ESP32C3 is a compact development board based on the ESP32C3 SoC. This MCB is designed to leverage the key features of the ESP32C3, in particular its wireless connectivity capabilities. At its core, the board uses a 32-bit RISC-V CPU and supports both IEEE Standard 802.11b, -g and -n (Wi-Fi 4) and Bluetooth Low Energy (BLE) of the Bluetooth 5.0 standard. 
In terms of interfaces, the chip provides four serial interfaces, including two UART, one I2C and one SPI, as well as eleven GPIO pins (which can be used for PWM), four ADC pins and one JTAG bonding pad interface. 
The board's design incorporates a small form factor with a single-sided surface mount layout, which is how it is mounted on the Dahal board. The board also includes a Hirose U.FL antenna interface for its wireless functionality. For user interaction, the MCB includes a small reset button and a bootloader mode button, as well as an LED indicator for the USB-C interface. The MCB's layout, pin-out and images are shown in Figure \ref{fig:esp32c3}, while a summary of the MCB's and MC's specifications can be found in Table \ref{tab:esp_comparison}. \citep{espressif_systems_esp32-c3_2024, seeed_studio_seeed_2024-2}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\textwidth]{overleaf/images/xiaoesp32c3.png}
    \\\vspace{\ftspace}
    \caption{Seeed Studio XIAO ESP32C3 pin-out schematic (left), layout (middle) and image(right) \citep[adapted from][]{seeed_studio_seeed_2024-2}}
    \label{fig:esp32c3}
\end{figure}

\textbf{Seeed Studio XIAO ESP32C6}\\\\
The Seeed Studio XIAO ESP32C6 is a compact development board based on the ESP32C6 SoC. This MCB is designed to leverage the key features of the ESP32C6, in particular its wireless connectivity capabilities. At its core, the board uses two 32-bit RISC-V CPUs and supports the IEEE Standard 802.11ax (Wi-Fi 6), BLE of the Bluetooth 5.3 standard and IEEE Standard 802.15.4 (Zigbee and Thread).
In terms of interfaces, the chip provides four serial interfaces, including one UART, one I2C, one LP\_I2C and one SPI, as well as eleven GPIO pins (which can be used for PWM), seven ADC pins, one SDIO interface. The board's design incorporates a small form factor. 
The board also includes an on-board antenna, as well as a Hirose U.FL antenna interface for its wireless functionality. For user interaction, the MCB includes a small reset button and a bootloader mode button, as well as an LED indicator for the USB-C interface. The MCB's layout, pin-out and images are shown in Figure \ref{fig:esp32c6}, while a summary of the MCB's and MC's specifications can be found in Table \ref{tab:esp_comparison}.  \citep{espressif_systems_esp32-c6_2024, seeed_studio_seeed_2024-1}
\begin{figure}[H]
    \centering
    \includegraphics[width=.6\textwidth]{overleaf/images/xiaoesp32c6.png}
    \\\vspace{\ftspace}
    \caption{Seeed Studio XIAO ESP32C6 pin-out schematic (left), layout (middle) and image (right) \citep[adapted from][]{seeed_studio_seeed_2024-1}}
    \label{fig:esp32c6}
\end{figure}

\begin{table}[H]
\begin{tabular}{|m{35pt}|m{55pt}|p{160pt}|p{175pt}|}
\hline
\multicolumn{2}{|c|}{\textbf{Products}} & \textbf{XIAO ESP32C6} & \textbf{XIAO ESP32C3} \\\hline
\multicolumn{2}{|c|}{\multirow{2}{*}{\textbf{Processor}}} & Espressif ESP32-C6 SoC & Espressif ESP32-C3 SoC \\\cline{3-4}
\multicolumn{2}{|c|}{} & Two 32-bit RISC-V processors, with the high-performance one running up to 160 MHz, and the low-power one clocking up to 20 MHz & RISC-V single-core 32-bit chip processor with a four-stage pipeline that operates at up to 160 MHz \\\hline
\multirow{4}{*}{\rotatebox{90}{\textbf{Wireless}}} & \textbf{Wi-Fi} & 2.4GHz Wi-Fi 6 subsystem & 2.4GHz Wi-Fi 4 subsystem \\\cline{2-4}
& \textbf{BLE} & Bluetooth 5.3, Bluetooth Mesh & Bluetooth 5.0, Bluetooth Mesh \\\cline{2-4}
& \textbf{Other} & Zigbee, Thread, IEEE 802.15.4 & / \\\cline{2-4}
& \textbf{Antenna} & U.FL interface with ext. antenna & On-board antenna + U.FL interface \\\hline
\multicolumn{2}{|c|}{\textbf{On-chip Memory}} & 512KB SRAM \& 4MB Flash & 400KB SRAM \& 4MB Flash \\\hline
\multicolumn{2}{|c|}{\multirow{2}{*}{\textbf{Interface}}} & 1x UART, 1x LP\_UART, 1x I2C, 1x LP\_IIC, 1x SPI, 11x GPIO(PWM),   7x ADC, 1x SDIO & 2x UART, 1x I2C, 1x SPI, 11x GPIO(PWM), 4x ADC \\\cline{3-4}
\multicolumn{2}{|c|}{} & \multicolumn{2}{c|}{1x Reset button, 1x Boot button} \\\hline
\multicolumn{2}{|c|}{\textbf{Dimensions}} & \multicolumn{2}{c|}{21 x 17.8 mm} \\\hline
\multirow{3}{*}{\rotatebox{90}{\textbf{Power}}} & \textbf{Input voltage} & \multicolumn{2}{l|}{\makecell{Type-C: 5V \\ BAT: 4.2V}} \\\cline{2-4}
 & \textbf{Circuit operating Voltage} & \multicolumn{2}{l|}{\makecell{USB:5V@9mA \\ BAT:3.8V@9mA}} \\\cline{2-4}
 & \textbf{Charging battery current} & 100mA & 350mA \\\hline
\multirow{3}{*}{\rotatebox{90}{\makecell{\quad\textbf{Power Consumption Model} \\ \quad\textbf{(Supply Power: 3.8V)}}}} & \textbf{Modem-sleep Model} & $\sim$30 mA & $\sim$24 mA \\\cline{2-4}
 & \textbf{Light-sleep Model} & $\sim$2.5 mA & $\sim$3 mA \\\cline{2-4}
 & \textbf{Deep Sleep Model} & $\sim$15 \micro A & $\sim$44 \micro A \\\hline
\multicolumn{2}{|c|}{\textbf{Working Temperature}} & \multicolumn{2}{c|}{-40°C $\sim$85°C} \\\hline
\end{tabular}
\vspace{\ftspace}
    \caption{Specification comparison of the ESP32C3 SoC- and ESP32C6 SoC-based MCB \citep[adapted from][]{seeed_studio_seeed_2024-2,seeed_studio_seeed_2024-1}}
    \label{tab:esp_comparison}
\end{table}

\subsubsection{\label{sec:rev_net}Networking}

Both the ESP32C3 SoC- and ESP32C6 SoC-based MCBs come with built in Bluetooth and Wi-Fi wireless networking capabilities, the latter of the two MBCs even includes additional hardware and support for the IEEE Standard 802.15.4 \citep{noauthor_ieee_2024} for low‐rate wireless networks. Both MCBs come with an antenna connector, with the latter even including a small on-board antenna.\\

\textbf{Bluetooth and Bluetooth Low Energy}\\\\
Bluetooth is a short-range wireless transmission technology standard, operating in the $2.4-2.485\ GHz$ industrial, scientific, and medical (ISM) radio band, with a radio class-dependant range of approximately 1 meter, 10 meters and 100 meters for Class 1, Class 2 and Class 3 respectively \citep[see][]{noauthor_basics_2012}. The standard was developed and is maintained by the Bluetooth Special Interest Group, which includes various companies as members. While initial specifications of Bluetooth were adopted by the Institute of Electrical and Electronics Engineers (IEEE) as part of the IEEE Standard 802.15 in 2002 \citep[Bluetooth 1.1,][]{noauthor_ieee_2002} and 2005 \citep[Bluetooth 1.2,][]{noauthor_ieee_2005}, these standards have since been withdrawn, with them instead maintained and released directly by the Bluetooth Special Interest Group. 
In addition to the classic Bluetooth protocol, with the release of the Bluetooth 4.0 standards, Bluetooth Low Energy (BLE) was introduced as a separate entity. As the name suggests, BLE is intended as a low-energy version of the classic Bluetooth for internet of things (IoT) applications \citep{noauthor_bluetooth_2017}.
While both classic Bluetooth and BLE maintain full backwards compatibility with earlier versions, the two protocols are not compatible with each other, though they can co-exist on the same device. \citep{noauthor_bluetooth_nodate}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Feature} & \textbf{ESP32C3} & \textbf{ESP32C6} \\\hline
        Bluetooth version & Bluetooth 5.0 Low Energy & Bluetooth 5.3 Low Energy \\\hline
        Maximum data rate & 2 Mbps & 2 Mbps \\\hline
        Frequency band & 2.4 GHz & 2.4 GHz \\\hline
        Frequency range & 2402 MHz & 2480 MHz \\\hline
        %Channel width &  &  \\\hline
        Range & Up to 4x of Bluetooth 4.2 & Up to 4x of Bluetooth 4.2 \\\hline
        Advertising channels & 3 & 3 \\\hline
    \end{tabular}
    \vspace{\ftspace}
    \caption{Specifications of Bluetooth standards found on the ESP32C3 and ESP32C6 SoCs \citep{noauthor_bluetooth_2024-1, noauthor_bluetooth_2024-2}}
    \label{tab:esp_bluetooth}
\end{table}
%\textbf{BLE on the ESP32C3 and ESP32C6}\\\\
The ESP32C3 supports BLE standards up to version Bluetooth 5.0 \citep{espressif_systems_esp32-c3_2024, seeed_studio_seeed_2024-2, noauthor_bluetooth_2024-2}, while the ESP32C6 supports BLE standards up to version Bluetooth 5.3 \citep{espressif_systems_esp32-c6_2024, seeed_studio_seeed_2024-1, noauthor_bluetooth_2024-1}. An overview of the two technologies is listed in Table \ref{tab:esp_bluetooth}.\\

\textbf{ESP-BLE-MESH}\\\\
The ESP32C3 and ESP32C6 SoCs' support for BLE adds support for Bluetooth Mesh. Bluetooth Mesh is a device mesh networking protocol based on BLE \citep{noauthor_bluetooth_2023, noauthor_bluetooth_2023-1}. Building on Bluetooth Mesh, Espressif Systems has developed ESP-BLE-MESH, a Bluetooth Mesh implementation specifically for ESP32 based devices.
Once formed, the ESP-BLE-MESH can become a large scale (1000+) interconnected peer-to-peer mesh. Nodes are connected to all other nodes within their range, with the topology of the network determined by heartbeat messages sent by nodes and received by other nodes in their vicinity. A mesh does not form automatically, but requires provisioning: to add nodes to the mesh, they must be provided with the necessary information and cryptographic key via a provisioning device, such as a smartphone.  
In terms of message transmission, ESP-BLE-MESH uses a controlled flooding approach, which means that a node sends a message to all other nodes to which it is connected. Specially designated gateway nodes forward the message to all their connected nodes, and so on. As the ESP-BLE-MESH is a fully interconnected mesh, there are many overlapping connections and routing possibilities, so in a controlled flooding approach a message is received by sheer brute force, with the possibility of nodes receiving the same message more than once, creating redundancy at the cost of inefficient routing and high network load. The ESP-BLE-MESH implementation is available for use with ESP32-based devices using the Espressif IoT Development Framework (ESP IDF) and standard ESP AT firmware, but there is currently no library implementation for ESP32 devices using MicroPython firmware. \citep{espressif_systems_esp-ble-mesh_nodate, noauthor_bluetooth_2023, noauthor_bluetooth_2023-1}\\

\textbf{Wi-Fi}\\\\
Wi-Fi is a family of wireless transmission technologies that enable wireless local area networks (WLANs), based on the original IEEE Standard 802.11 and its amendments \citep[][]{noauthor_ieee_2024}, and certified for interoperability by the Wi-Fi Alliance \citep{noauthor_certification_2020}. The Wi-Fi Alliance, like the Bluetooth Special Interest Group, is a membership-based group of companies that includes most of the manufacturers of IEEE Standard 802.11-based technology. \citep{noauthor_wi-fi_nodate} Wi-Fi operates in the $2.4\ GHz$ ISM band, the same band used by Bluetooth, although newer versions also use the 5 GHz and 6 GHz frequency bands. Range and transmission bandwidth are highly dependent on the specific IEEE standard used, which usually corresponds to the Wi-Fi generation. Wi-Fi generations are mostly backwards compatible with earlier generations and standards.

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        & \textbf{ESP32C3} & \textbf{ESP32C6} \\\hline
        Wi-Fi Generation & Wi-Fi 4 & Wi-Fi 6 \\\hline
        IEEE Standard & 802.11n & 802.11ax \\\hline
        Maximum data rate & 600 Mbps & 9.6 Gbps \\\hline
        Frequency band & 2.4 GHz & 2.4 GHz \\\hline
        Frequency range & 2402-2482 MHz & 2402-2482 MHz \\\hline
        Channels & 13, 11 & 13, 11 \\\hline
        Channel width & 20, 40 MHz & 20, 40 MHz \\\hline
        MIMO streams & Up to 4 & Up to 8 \\\hline
        Modulation & Up to 64-QAM & Up to 1024-QAM \\\hline
        %OFDMA & No & Yes \\\hline
        %Target Wake Time & No & Yes \\\hline
        %MU-MIMO & No & Yes (Uplink and Downlink) \\\hline
    \end{tabular}
    \vspace{\ftspace}
    \caption{Specifications of Wi-Fi standards as implemented on the ESP32C3 and ESP32C6 SoCs \citep{noauthor_ieee_2009, noauthor_ieee_2021}}
    \label{tab:esp_wifi}
\end{table}

%\textbf{Wi-Fi on the ESP32C3 and ESP32C6}\\\\
The ESP32C3 SoC supports the IEEE Standard 802.11b, -g and -n, which correspond to Wi-Fi 1\footnote{\label{note:wifi_name}Wi-Fi 0, Wi-Fi 1, Wi-Fi 2 and Wi-Fi 3 were names not used in proper Wi-Fi nomenclature, but are retrospectively inferred to the respective IEEE standards with the introduction of the IEEE Standard 802.11n, which was named Wi-Fi 4 by the Wi-Fi Alliance, with which official Wi-Fi generation numbering began. \citep{wi-fi_alliance_generational_2023}}, Wi-Fi 3\footnote{See Footnote \ref{note:wifi_name}} and Wi-Fi 4 respectively \citep{seeed_studio_seeed_2024-2, espressif_systems_esp32-c3_2024, wi-fi_alliance_generational_2023, noauthor_ieee_2000,noauthor_ieee_2003, noauthor_ieee_2009}, while the ESP32C6 SoC supports the IEEE Standard 802.11ax, which corresponds to Wi-Fi 6 \citep{seeed_studio_seeed_2024-1, espressif_systems_esp32-c6_2024, wi-fi_alliance_generational_2023, noauthor_ieee_2021}. In both cases, the frequency band used is the $2.4\ GHz$ ISM band due to hardware restrictions, despite both Wi-Fi 4 and Wi-Fi 6 protocols supporting higher frequency bands as well. An overview of the two generations used by the two SoCs is given in the Table \ref{tab:esp_wifi}.\\

\textbf{ESP-Wi-Fi-Mesh}\\\\
Based on standard Wi-Fi protocols, Espressif Systems has developed ESP-WIFI-MESH, a mesh networking implementation specifically for ESP32-based devices. Traditionally, in a Wi-Fi network, all peers are connected directly to the AP in a hub-and-spoke fashion. With ESP-WIFI-MESH, nodes outside the range of the AP, but within range of the root node connected to the Wi-Fi, or an intermediate node connected to the root node either directly or via another intermediate note, can be connected to the Wi-Fi. This is done by creating multiple Wi-Fi networks, taking advantage of the fact that the ESP32 devices have two Wi-Fi interfaces (one Wi-Fi and one AP), allowing nodes to host their own network while being connected to another network. The mesh network hence forms a tree-like structure with a maximum depth of four layers, starting from a root node that is either manually selected or automatically selected based on the RSSI strength of beacon frames from a Wi-Fi router or access point (AP). The network operates autonomously, is self-organising and has self-healing capabilities should a node become inoperable. To form the network, connected nodes, starting with the root node, send out Wi-Fi beacon frames, which inform nodes in their vicinity of their presence. Upon receiving one or more such signals, the surrounding node then connects to a possible parent node, first considering the depth of the parent node, choosing the less deep, followed by the number of children of two similarly deep parent nodes, choosing the one with fewer children. Since the topography of the network is defined, not intertwined, and the root and parent nodes know their respective subnets (in the form of a table or table of tables of MAC addresses), nodes can forward messages directly to the respective child or intermediate child node if the MAC is contained in their table. If the MAC cannot be found, i.e. it is not part of that parent node's subnet, the node sends the message to its parent node, and so on until it reaches the root node, which has information about the entire mesh network. As the MC have two MAC addresses, one for the AP and one for the Wi-Fi, the Wi-Fi MAC address is used as an identifier.
The ESP-WIFI-MESH implementation is available for use with ESP32-based devices using the Espressif IoT Development Framework (ESP IDF) and standard ESP AT firmware, but there is currently no library implementation for ESP32 devices using MicroPython firmware. \citep{espressif_systems_esp-wifi-mesh_nodate}\\

\textbf{PainlessMesh}\\\\
The PainlessMesh library is an open source project written in C++ for ESP32-based devices using Arduino, and enables the creation of ad-hoc, decentralised, stand-alone, Wi-Fi-based network meshes. The project is written using native ESP32 SDK libraries. The mesh is self-organising, self-healing and somewhat decentralised in structure, meaning that there is no central root node, although a central root node can be set if required. During formation, a node first considers which AP to join based on the list of other nodes to which it is connected (either directly or indirectly), thus avoiding loops in the network, and then the second choice is based on the RSSI value. This is possible because the topology of the mesh is known to all nodes and is constantly updated. As such, the structure of the mesh contains no entanglement, as nodes can only connect to one AP, but multiple nodes can connect to the same AP, although there is a risk of multiple separate mesh networks being formed. To prevent the formation of multiple smaller networks, nodes disconnect and randomly connect to different nodes to form a single coherent mesh, although this process is random and time consuming. Message transmission is simple as there is only one route between any two nodes and all nodes are aware of the entire network topology. The ESP32 chip ID is used as a unique identifier and for readability, messaging is JSON based.
PainlessMesh is designed to work with Arduino and is available for use with ESP32-based devices using Arduino firmware, but there is currently no library implementation for ESP32 devices using MicroPython firmware. \citep{van_leeuwen_painlessmesh_2019}

\textbf{ESP-NOW}\\\\
ESP-NOW is connectionless communication protocol, created by Espressif Systems, which uses Wi-Fi management frames to transmit small messages in a peer-to-peer or peer-to-all fashion. A Wi-Fi Management Frame is a type of message defined by the IEEE Standard 802.11 \citep{noauthor_ieee_2024-1}, which are data packets used to manage and control Wi-Fi connections. To this end, since management and control of a connection is independent of the actual connection, they can be transmitted to and received by any Wi-Fi enabled device, even if it is not connected to any network, as long as the frame is addressed to the MAC address of that device or the broadcast MAC address (\textit{xff:0xff:0xff:0xff:0xff:0xff}) in the MAC-Header. Specifically, in the MAC header, the first address is set to the receiver MAC address, the second address is set to the transmitter MAC address, and the third address is set to the broadcast MAC address. The specific management frame used is the Vendor-Specific Action Frame (category code 127), the structure of which is shown in Table \ref{tab:managementframe}. The Organisation Identifier is set to \textit{0x18fe34} for Espressif systems. The Vendor Specific Content, shown in Table \ref{tab:vendorpecificcontent}, is of particular interest as it provides space in the body field for custom content that ESP-NOW uses to transmit its message. The space available is $250\ bytes$, which is the maximum message length of ESP-NOW v1.0, although there is a newer version, ESP-NOW v2.0, which increases the maximum message size to $1490\ bytes$. While devices using ESP-NOW v2.0 can receive messages from ESP-NOW v1.0 devices, the reverse is only true if the v2.0 message is $250\ bytes$ or less. Looking at the OSI network model, ESP-NOW operates at a low level, just above the physical hardware layer and the data link layer.

\begin{table}[H]
    \centering
    Vendor-Specific Action Frame:
    \begin{tabular}{|c|c|p{70pt}|c|p{70pt}|c|}
        \hline
        \textbf{MAC-Header} & \textbf{Category Code} & \textbf{Organization Identifier} & \textbf{Random Values} & \textbf{Vendor Specific Content} & \textbf{FCS} \\
        \hline\hline
        ... & \textit{127} & \textit{0x18fe34} & \textit{random} & \textit{see Table \ref{tab:vendorpecificcontent}} & ... \\
        \hline\hline
        $24\ bytes$ & $1\ byte$ & $3\ bytes$ & $4\ bytes$ & $7-255\ bytes$ & $4\ bytes$ \\
        \hline
    \end{tabular}
    \vspace{\ftspace}
    \caption{Structure of Management Frame data packet, which with category code \textit{127} becomes a Vendor-Specific Action Frame \citep[adapted from][]{espressif_systems_esp-now_nodate}}
    \label{tab:managementframe}
\end{table}

\begin{table}[H]
    \centering
    Vendor Specific Content:
    \begin{tabular}{|c|c|p{70pt}|c|c|c|c|}
        \hline
        \textbf{Element-ID} & \textbf{Length} & \textbf{Organization Identifier} & \textbf{Type} & \textbf{Version} & \textbf{Body} \\
        \hline\hline
        \textit{221} & \textit{length} & \textit{0x18fe34} & \textit{4} & \textit{ESP-NOW version} & \textit{...} \\
        \hline\hline
        $1\ byte$ & $1\ byte$ & $3\ bytes$ & $1\ byte$ & $1\ byte$ & $0-250\ bytes$ \\
        \hline
    \end{tabular}
    \vspace{\ftspace}
    \caption{Vendor Specific Content structure for ESP-NOW packet \citep[adapted from][]{espressif_systems_esp-now_nodate}}
    \label{tab:vendorpecificcontent}
\end{table}

In terms of usability, ESP-NOW runs on an initialised Wi-Fi or AP interface as it uses Wi-Fi management frames to transmit its messages. With an initialised ESP-NOW service, a device will be able to receive all messages addressed to it, while for sending, the MAC address of the peer must first be added to the ESP-NOW, and only then can messages addressed to its MAC address be sent. However, the broadcast MAC address (\textit{xff:0xff:0xff:0xff:0xff:0xff:0xff}) can also be added and then used to send to any device in range with an initialised ESP-NOW.  The buffer for receiving messages is $20$, at which point older messages will be discarded if they have not been verified. In any case, proper handling of received messages to prevent loss of received messages is required, based on an interrupt handler (IRQ) running with high priority Wi-Fi tasks. ESP-NOW can use any of the $14$ available Wi-Fi channels to transmit and receive messages. In the case of the ESP32C3 and ESP32C6, since both chips have separate Wi-Fi and AP interfaces, both can be used to send and receive ESP-NOW messages, which theoretically also allows messages to be transmitted and received on two channels simultaneously. For the ESP32C3, which includes an external antenna, the claimed range of ESP-NOW is up to $220\ metres$. ESP-NOW v1.0 and v2.0 are available for use with ESP32-based devices using standard ESP firmware and Arduino firmware. Furthermore there is also an implementation of ESP-NOW v1.0 within the ESP32 MicroPython firmware, which is used on the SM. \citep{espressif_systems_esp-now_nodate, micropython_micropython_2025}\\

%\begin{figure}
%    \centering
%    \includegraphics[width=0.5\linewidth]{overleaf/images/placeholder.png}
%    \vspace{\ftspace}
%    \caption{ESP-NOW architecture}
%    \label{fig:espnowarchitecture}
%\end{figure}

\textbf{ESP-NOW MicroPython Wi-Fi Mesh}\\\\
As part of a Master's thesis at the Brno University of Technology and a subsequently published conference paper, a dynamic, autonomous and self-healing mesh network was designed, developed and tested using ESP32 MCs running MicroPython firmware, using both ESP-NOW and shared Wi-Fi to create a mesh. The mesh topology is based on a tree structure, with the connection between nodes based on Wi-Fi, using both Wi-Fi and AP modules to create a network for children while connecting to a parent node AP, similar to the ESP Wi-Fi mesh. This Wi-Fi mesh is used for data transmission, including topology updates, where the transmission is done using a routing model as the topology of the network is known and the structure requires routing due to the nature of the network. ESP-NOW, on the other hand, is used to manage the network, including finding and adding new nodes to the network using a flooding approach.
The thesis attempted to use this approach, but found that a mesh of six nodes worked well, but when seven or more nodes were used, memory problems began to occur, causing the mesh network to become unstable. 
%The approach and results of the thesis were published as a conference paper at the Excel@FIT 2022 conference in Brno.
\citep{sestak_dynamic_2022, sestak_dynamic_2022-1}
\\

\textbf{IEEE 802.15.4}\\\\
In addition to Wi-Fi and BLE, the ESP32C6 also includes an additional wireless baseband and MAC compliant with the IEEE 802.15.4 protocol. This protocol outlines low-rate wireless personal area networks with low complexity, low data rates and very long durations, dealing with the OSI physical and data link layers. The standard is the basis for protocols such as Zigbee and Thread, both of which are supported by the ESP32C6. \citep{noauthor_ieee_2024, noauthor_ieee_2009, espressif_systems_esp32-c6_2024, seeed_studio_seeed_2024-1, seeed_studio_seeed_2024}

%\subsubsection{\label{sec:rev_grove}Seed Studio Grove}
%Quick intro about grove environment and its sensors.

\subsection{\label{sec:methods_net_des}Networking Requirements and Concept Design}

As a first step, a number of requirements for the development of the networking concept were identified and set out here:
\begin{itemize}
    \item Compatible with Smart Motor hardware and software
    \item Decentralised peer-to-peer application (no central root or hub)
    \item Easy module discovery and interaction
    \item Incorporation of simple command and response logic, data transmission and simple message validation
\end{itemize}

Based on the technology studied and the requirements outlined above, ESP-NOW was chosen as the basis for the networking protocol because of its low-tech, peer-to-peer, non-connected functionality and its ready availability on the hardware and firmware used for the SM. A further advantage is that ESP-NOW is easy to set up, it works out of the box and does not require any configuration or pairing for transmissions to take place, the setup can be done in a few simple lines of code and once initialised runs in the background, allowing a main program to run while still allowing networking based on IRQ handling, making it compatible with most main module code.\\\\
In a second step, using the ESP-NOW protocol as a base, a more detailed networking concept was developed, taking into account the ESP-NOW capabilities and limitations. This included the design of a common message structure, providing for different types of messages, allowing for predetermined handling based on identifiers and codes, and measures to identify the message and check its validity. In order to support this concept of command type messages, the following basic message types have been defined, which should also be reflected in the message structure: Command (\textit{cmd}), Information (\textit{inf}) and Acknowledgement (\textit{ack}).
\textit{Cmd} messages require some sort of handling or action to be performed by the receiving device. 
\textit{Inf} messages are the standard type of message, containing some sort of information or data, such as sensor data, that could be used by the MC's main programme. \textit{Ack} message are responses, either to commands or to information messages, which acknowledge or confirm the command, or may be the direct result of a command returning an information message, such as the proposed ping message (\textit{cmd} type) which should initiate a pong response (\textit{ack} type). To allow for a variety of these base message types, they should be able to contain different sub-types.
As ESP-NOW uses the MAC address of the receiver to address and send messages, which may not be known to the device, a way of identifying the surrounding modules must be implemented. To this end, the library should include an address book to store the MAC addresses as well as associated information such as name, configuration and the Wi-Fi channel used for transmission. 
It should also attempt to find a way around the $20$ peer limit of the ESP-NOW peer buffer (for unencrypted messages), as well as examining the $250\ byte$ message limit and considering a way to send longer messages.
The library should also be designed to be adaptable and usable as a block based on other message subtypes and commands and their respective handling logic.
In addition, coding standards and best practices such as the Python Enhancement Proposal 8 outlined in the Python style guide \citep{rossum_python_2001} should be applied. The following design principles were outlined for consideration in the development of the network protocol:
\begin{itemize}
    \item Accessibility (in terms of usability)
    \item Simplicity (in terms of comprehension, usability and accessibility)
    \item Flexibility (in terms of application)
    \item Adaptability (in terms of flexibility and application)
\end{itemize}

\subsection{\label{sec:methods_ssp_des}Platform Architecture and Design}

In order to support the networking capability, and given the evolution of the Smart Motor, a broader platform was conceived, named the Smart System Platform.

Defined the idea, structure, goals, framework, key necessities and guiding principles and why. 
Focus on capabilities and accessibility for educational project / lesson development. 
\subsubsection{\label{sec:methods_nomenclature}Nomenclature}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|}
    \hline
        Smart System Platform (SSP) & The Platform \\\hline
        Hardware        & Phyiscal parts of the Smart System Platform \\\hline
        Module          & Stand alone modules, such as the Smart Motor \\\hline
        Component       & Hardware contained in the module, such as sensors, motors etc. \\\hline
        Input           & Component that provides data input, such as a sensor \\\hline
        Output          & Component that provides output, such as a motor \\\hline
        UI              & Components that are used to be interacted with  \\\hline
        Software        & Code files and library saved and running on a Module \\\hline
        Library         & A file to enable a component or capability to work on the module \\\hline
        Networking      & The networking library \\\hline
        Firmware        & Firmware running on a Module \\\hline
        Documentation   & Documentation for the Smart System Platform, its modules incl. the website, the development and management tools and the GitHub \\\hline
        Website         & The Website, hosting information and the dev suite, part of documentation \\\hline
        GitHub          & The GitHub page of the Smart System Platform hosting code and all the files \\\hline
        Management Tool & PyScript page, part of the website. \\\hline
        IDE             & PyScript page, part of the website \\\hline
    \end{tabular}
    \vspace{\ftspace}
    \caption{Nomenclature for the Smart System Platform}
    \label{tab:nomenclature}
\end{table}

Design of the Platform, what parts does it need, go into detail about the different parts of the platform, identify the aspects, key capabilities, hosting, guides and whatever. 

What aspects are important? Hardware and Software of the smart system, mention all the networking capabilities etc. Module hardware ideas. Mention the many hardware components that could be used! Modularity!

IDE for easy development using smart system modules and interactions as well as lessons. Mention the difficulty of hard coding and how it is great to do learning by doing, but 

Key stakeholders, who is it for?

Website, accessibility, information. Free to use, all info publicly available, hosted on GitHub, including website and development tools and guides.

Also mention the development of similar projects and testing od educational experiences, which are often done from scratch. Allow the use of the SSP as an unrestricted platform to develop own lessons, projects and experiences on, using existing capabilities. 

\section{\label{sec:methods_ph2}Phase 2: Development}

\subsection{\label{sec:methods_net_dev}Networking Development}

%Code structure, Commands, Interactions, etc. Message flows, message types, large message handling, IRQ implementation, all commands and handlers Setup with congif, networking and ssp\_networking Boop-o-meter

Given the the requirements and concept for the networking protocol defined in Section \ref{sec:methods_net_des}, the networking library has been split into two parts, the base networking library, which contains the basic networking logic and the more specific SSP networking library, which contains more SSP specific networking logic.

\subsubsection{\label{sec:methods_networking}Base Networking Library}

%\textbf{\label{sec:methods_additional}Additional Considerations}\\\\

As outlined in Section \ref{sec:methods_net_des}, ESP-NOW uses MAC addresses to address messages, however, these addresses might not be know beforehand. To this end an address book is included in the networking library, which is automatically populated when a message is sent to a new MAC address or received from an unknown MAC address. In order to be able to discover and gather information about the surrounding modules, the ping command message outlined before, contains information about the sender, such as name and configuration. This ping command can be sent out to the general broadcast address and when received by any device running the networking library, prompts that devices to return a pong message to the sender, which in turn contains information about itself. In this scenario, both devices have now added each other to their respective address books, which includes the mac address, name and configuration. This address book, however, is not persistent and the information is lost upon reboot of the device. In addition, an echo command, which prompts the receiver to return the same message content to the sender, and a boop command, which is intended to calculate and return the stored RSSI values of the last message of every MAC address a message was received from, were also designed as key commands to be included in the base network.\\

\textbf{\label{sec:methods_msg_struct}Message Structure}\\\\
The message structure developed for the networking library is shown in Table \ref{tab:msg_struct}. The message starts with a header ($0x2a$, 1 byte) which is used to identify that the message has been sent by a friendly networking library. 
This is followed by the message type, which currently identifies the message as one of the three different message types ($0x01$ for \textit{cmd}, $0x02$ for \textit{inf} and $0x03$ for \textit{ack}, $1\ byte$) defined in Section \ref{sec:methods_net_des}. 
The type is followed by the message subtype, which identifies the specific subtype of the message (\textit{cmd}: $0x10$ for \textit{ping}, $0x13$ for \textit{boop} and $0x15$ for \textit{echo}; \textit{inf}: $0x20$ for \textit{boop response}, $0x21$ for \textit{data} and $0x22$ for \textit{message}; \textit{ack}: $0x10$ for \textit{pong} and $0x15$ for \textit{echo}), although only a few subtypes are defined in the basic network. However, the library has provisions to allow the user to define their own message subtypes and their respective handling logic, as is done in the more application specific SSP networking library.
The timestamp is populated at the time of sending with \verb!time.ticks\_ms\end!, which is the time in milliseconds since the device was started. \verb!time.ticks\_ms! returns a $32-bit$ unsigned integer, ensuring that it always stays under $4\ bytes$ by rolling over when it reaches its maximum value. In the case of a $32-bit$ integer, the maximum would be $2^{32} -1\ ms = 4'294'967^295\ ms = 49.71\ days$. However, according to the MicroPython documentation \citep{micropython_micropython_2025-1}, the exact maximum size of \verb!time.ticks\_ms\! in MicroPython is opaque, although in the case of the MicroPython implementation for ESP32s, the maximum size appears to be only 30 bits, resulting in a maximum of $2^{30}-1\ ms=1'073'741'823\ ms = 12.43\ days$.
As such, the timestamp is only used to calculate relative durations or differences, for example in the ping command, where the timestamp is returned to the original sender, who then calculates the ping time, the time it took for the message to travel back and forth.
The data type field is used to identify the encoding of the payload, as the network code allows the following data types to be encoded: \textit{integer}, \textit{string}, \textit{float}, \textit{list}, \textit{dictionary}, \textit{bytes} and \textit{bytearray}. In addition, the data type is also used to identify long messages, i.e. when a payload longer than $241\ bytes$ is split and sent using multiple messages. In this case the payload type is set to the long message code, where the payload contains its own structure, namely the part number of the message, the total number of parts of the long message and the payload type of the message. Taking into account these three additional meta-informations, each of which occupies one byte per message, the remaining payload is $238\ bytes$. With one byte allocated to the part number of the message, the maximum number of parts is $256$ as the part number is stored in $1\ byte$, giving a theoretical payload limit of $256*238\ bytes = 60'928\ bytes$. The logic of long message handling is further defined in Section \ref{fig:net_recv_logic}. With eight options, the data type field is ($1\ byte$).
This is followed by the data field containing the payload. This payload is encoded depending on the type of data, with the field holding a maximum of $241\ bytes$.
Finally, the message structure contains a $1\ byte$ checksum to confirm the integrity of the message. The checksum is calculated by taking the sum of all the preceding fields and calculating the modulus of the sums divided by $256$, ensuring a number smaller than $256$ and therefore fitting into the $1\ byte$ space allocated to it. 
However, the message structure does not include the sender's MAC address, as this is already passed by ESP-NOW and included in the surrounding Wi-Fi management frame.

%in the message structure (250 bytes - 9 bytes, which are used for identifier, types, subtypes, send time payload type and the checksum). This is achieved by splitting the data into multiple messages, up to 256 parts, resulting in a total theoretical maximum payload of 60'928 bytes (256 x 238 bytes). The payload is reduced to 238 bytes because 3 additional variables are used to identify the message, the payload type to identify a long message, the actual payload type, the total number of messages and the current message number.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|}
        \hline
        Header & Type & Sub-Type  & Timestamp & Data Type & Data & Checksum \\
        ($1\ byte$) & ($1\ byte$) & ($1\ byte$) & ($4\ bytes$) & ($1\ byte$) & ($241\ bytes$) & ($1\ byte$) \\
        \hline
        Identifier & Number & Number & Number & Number & \textbf{Payload} & Number \\
        0x2a & (1-3) & (0-255) & $time.ticks\_ms()$ & (0-6) & ... & $sum() \% 256$ \\
        \hline
    \end{tabular}
    \vspace{\ftspace}
    \caption{Networking Message Structure}
    \label{tab:msg_struct}
\end{table}

\subsubsection{\label{sec:methods_send_logic}Send Logic}

The send logic of the networking library

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{overleaf/images/send_logic.drawio.png}
    \vspace{\ftspace}
    \caption{Networking Message Send Logic}
    \label{fig:net_send_logic}
\end{figure}

\subsubsection{\label{sec:methods_recv_logic}Receive Logic}

The receive logic of the networking library is more complex, starting out as a linear pipeline and then branching into different branches to handle the various message types, as outlined in Figure \ref{fig:net_recv_logic}. 

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{overleaf/images/receive_logic.drawio.png}
    \vspace{\ftspace}
    \caption{Networking Message Receive Logic}
    \label{fig:net_recv_logic}
\end{figure}

%\textbf{\label{sec:methods_additional}Additional Considerations}\\\\

\subsubsection{\label{sec:methods_ssp_networking}SSP Networking}

Given the complexity of the platform specific, the networking structure was split into two components, the base networking structure, which handles sending, receiving and defines basic commands such as ping, echo, boop, the message and data message types, as well as interfaces to set system parameters and information and build and define custom commands and message types and their respective handlers. And a SSP-specific networking library, which defines a multitude of SSP-specific commands and message types and subtypes, as well as the respective custom command handlers. 

\begin{figure}[H]
    \centering
    \includegraphics[width=.6\linewidth]{overleaf/images/code_structure.png}
    \vspace{\ftspace}
    \caption{Networking Code Structure}
    \label{fig:net_code_structure}
\end{figure}

\begin{figure}[H]
	\centering%
    \begin{subfigure}[b]{0.45\textwidth}%
      	\includegraphics[width=\textwidth]{overleaf/images/networking_structure.drawio.png}%
    \end{subfigure}%
    \hspace{0.05\textwidth}
    \begin{subfigure}[b]{0.45\textwidth}%
        \includegraphics[width=\textwidth]{overleaf/images/ssp_networking_structure.drawio.png}%
    \end{subfigure}%
    \vspace{\ftspace}
    \caption{networking.py and ssp\_networking.py code structure}
    \label{fig:net_net_structure}
\end{figure}

\subsection{\label{sec:methods_ssp_dev}Smart System Platform Development}

In addition to the concept and design of the Smart System Platform, described in Section \ref{sec:methods_ssp_des}, several components have been developed, which are described in this section. These include parts of the documentation, such as the GitHub page and the website, including the various networking development and management tools developed in PyScript that are part of the website.

\subsubsection{\label{sec:methods_gh}GitHub}
As part of the software development, a public GitHub page has been created for this thesis to host the code and development progress for the network. However, in line with the goal of accessibility, the public GitHub page also serves as the main host for all other information and resources of the Smart System Platform, including the website, all data related to this thesis, and more, with the exception of PyScript. The site is licensed under the MIT licence. 

In terms of organisation, the page is divided into SSP folders, namely docs, which contains the website files, firmware, which contains the firmware files, hardware, which contains the hardware related files and software, which contains the code. There are also thesis-specific folders, overleaf, which host the thesis report, and RStudio, which hosts the draft automated README files and any experimental data that has been analysed. The GitHub is connected to overleaf and RStudio to allow for automatic . There are also two hidden folders, .github, which hosts the custom GitHub workflows, and the .git folder, which hosts git-specific files.

In terms of branches, the GitHub has been split into two parts, with the main branch becoming protected and development done in subversion of the /dev branch. Development done by the author is hosted in the dev/nick branch. This was done in an effort to protect the main release versions of the code from accidental editing.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{overleaf/images/placeholder.png}
    \vspace{\ftspace}
    \caption{GitHub Workflow, Branches and Automation}
    \label{fig:enter-label}
\end{figure}

In terms of automation, the building of the website is automated and triggered whenever there is a push or merge to the main branch. 

In addition to the website being built, there is a custom render and release pipeline triggered by merge commits. The main branch is restricted and can't be committed to directly, but requires a pull request to be submitted and approved. The pipeline is triggered when the pull request is approved and merged. It then automatically populates the release folder with all the code files from their various locations, and updates config.py with the version of those files. The pipeline then renders all the Quarto Markdown README files, updating them to include the latest file structure and information about the respective folders and locations. Finally, the pipeline merges the above changes back into the branch from which the pull request originated.

\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{overleaf/images/readme.png}
    \vspace{\ftspace}
    \caption{Exampe of the README.md file, which is used to give information about the current directory and its files}
    \vspace{\ftspace}
    \label{fig:readme}
\end{figure}


\subsubsection{\label{sec:methods_website}Website}
The website, which is hosted as part of the GitHub.

Main design principles are accessibility, conversation of information and outreach.

Compatibility for desktop and mobiles. 

Design principles are simplicity and the Swiss design style was used. 


All parts of the website, guides, introduction, other relevant information. 


\subsubsection{\label{sec:methods_pyscript}PyScript}

\textbf{\label{sec:methods_ide}Integrated Development Environment}\\\\
In an effort to create an independent online IDE. It requires no installation of any software and works out of the box in the chrome browser, which allows websites to connect to connected devices via various interfaces, including via USB to the REPL of the ESP32 devices.

Facilitate development of networked devices, which is why multiple separate development tabs are supported.

This was based on an earlier version hosted here: and customised with SSP development and networking in mind. 

Usability and accessibility
pyscript, ui and whatnot. \\

\textbf{\label{sec:methods_nmt}Network Management and Module Configuration Interface}\\\\
Usability and accessibility
pyscript, ui and whatnot. \\

\textbf{\label{sec:methods_up}Module Management Portal}\\\\
To update the files on a respective module, the module page has been developed, which checks the config.py file for versions numbers against the latest config.py file on the release branch of the GitHub. If a discrepancy exists the respective files are downloaded directly onto the device from GitHub, updating the software on the device to its newest version, based on its specific configuration.

Usability and accessibility
pyscript, ui and whatnot. 

\subsubsection{\label{sec:methods_sw}Software}

\textbf{\label{sec:methods_main}main.py and boot.py}\\\\
As part of the platform, a customisable boot program was written.

Automatically calls the respective main.py from within boot based on a value in config.py. Tough it initialises networking first, allowing the module to be discoverably and receive messages and commands. 
The main.py furthermore enables the the configuration command to be used to configure the module as part of the hive modules concept, sending messages, receiving data and configuring how to use that received data.\\

\textbf{\label{sec:methods_libraries}Libraries}\\\\

\subsubsection{\label{sec:methods_hw}Hardware}
Modules, overview of existing technology, go into the analysis results of the used software, firmware and chips, how modular they are and what could be used for them and show the graphics with example input / output matrix.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{overleaf/images/placeholder.png}
    \vspace{\ftspace}
    \caption{Hardware matrix with possible inputs and outputs}
    \label{fig:hardware}
\end{figure}

Mention that in addition to the SMs, various hardware modules were developed for the ongoing Smart Playgrounds project.

\subsubsection{\label{sec:methods_fw}Firmware}
Mention that it was considered to develop own firmware with developed capabilities, but consideration of ease of reproducibility and use against high customisation of used firmware, yet a little customisation was needed.

\section{\label{sec:methods_ph3}Phase 3: Testing and Validation}
Validation, us of the platform, its tools and capabilities.
Mention the use of capabilities in other projects, such as the playground project, by some students for own little projects and stuff.
Hackathon
Example Kit and Projects (Music box, 

\subsection{\label{sec:methods_test_net}Networking}

To test the networking and the developed library, the following aspects were tested.

\subsubsection{\label{sec:methods_test_boop}Robustness - Boop-o-Meter}
In an effort to test the reliability and sturdyness of the 
Boop-o-Meter design etc, which is a small device which can send a message to either one selected
can be found in Appendix \ref{chap:apx_e}. The results of this test are outlined in Section \ref{sec:res_reliability}.

\subsubsection{\label{sec:methods_test_range}Range}
A further test was carried out to determine the maximum range at which messages could still be received, using the same programme as described for the robustness test, the code for which can be found in Appendix \ref{chap:apx_e}. Given the range requirements for this test, the test was conducted outdoors on a straight road between the CEEO offices and the Tufts campus to ensure an uninterrupted line of sight. 
Two people, connected by voice chat, walked away from each other on the street and periodically sent messages to each other from the MCB. At the point where neither person was receiving messages, their positions were marked and the final distance was calculated using Google Earth. The results of this test are outlined in Section \ref{sec:res_range}.

\subsubsection{\label{sec:methods_test_rssi}Response Time, RSSI and Packet Loss Rate by Range}
can be found in Appendix \ref{chap:apx_e}.

\subsubsection{\label{sec:methods_test_angle}Antenna Angle Effects on RSSI and Ping}
Based on anecdotal observation by the Smart Playground project, which used ESP32C3 and ESP32C6 devices with this networking library, the effect of relative antenna angle between two devices was tested at a pre-defined distance of 50 centimetres. The same program used to calculate the response time, RSSI values and package loss rate for various distances was used for this test, the code for which can be found in Appendix \ref{chap:apx_e}. The results of this test are outlined in Section \ref{sec:res_angle}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{overleaf/images/angletest.drawio.png}
    \vspace{\ftspace}
    \caption{Test set up to test antenna angle effects on response time, RSSI and packet loss rate by range}
    \label{fig:angle}
\end{figure}

\subsubsection{\label{sec:methods_test_batter}Power Consumption}

can be found in Appendix \ref{chap:apx_e}. The results of this test are outlined in Section \ref{sec:res_battery}.

\subsection{\label{sec:methods_tools}Smart System Platform: GitHub, Tools and Website}
Mention the test for the website accessibility, and that I tested the tools for 

the website was to be tested with the Google for Developers PageSpeed Insights

True test for the website, the GitHub and the tools was during the two Hackathons, outlined in Section \ref{sec:methods_hackathon1} and Section \ref{sec:methods_hackathon2} and by people using the as outlined in and Section \ref{sec:methods_other}.

\subsubsection{\label{sec:methods_example}Example}
Mention the two examples I built with two Smart Motors controlling each other. The results of this are described in Section \ref{sec:res_examplekit}.

\subsection{\label{sec:methods_hackathon1}Hackathon 1}

Describe Hackathon 1, during which the Robustness test of the Networking library was performed. 
Furthermore, in a second task, the use of the networking library and development of a simple networked project, using smart motor hardware was done. 

\subsection{\label{sec:methods_hackathon2}Hackathon 2}

Describe Hackathon 2

\subsection{\label{sec:methods_other}Use in Other Projects}

\subsubsection{\label{sec:methods_me35}ME35}
Some students have used the GitHub and main networking code for some of their class projects as part of ME35.

\subsubsection{\label{sec:methods_smart_playground}Smart Playground}
Introduce project and that code and some of the ideas outlined in Section \ref{sec:methods_ssp_des} and Section \ref{sec:methods_ssp_dev} were used for this project.

